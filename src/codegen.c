#include "codegen.h"
#include "ast.h"
#include "string_literals.h"
#include "array_ops.h"     // For array operations
#include "pointer_ops.h"   // For pointer operations
#include "type_support.h"  // For type operations
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Output file for assembly code
FILE* asmFile = NULL;

// String literals table
int stringLiteralCount = 0;
char** stringLiterals = NULL;

// Label counter for unique labels
int labelCounter = 0;

// Current function being generated
static char* currentFunction = NULL;

// Variable tracking for stack offsets
#define MAX_LOCALS 64
typedef struct {
    char* name;
    int offset;
} LocalVariable;

static LocalVariable localVars[MAX_LOCALS];
static int localVarCount = 0;
static int stackSize = 0;

// Clear local variables when entering a new function
void clearLocalVars() {
    for (int i = 0; i < localVarCount; i++) {
        if (localVars[i].name) {
            free(localVars[i].name);
        }
    }
    localVarCount = 0;
    stackSize = 0;
}

// Add a local variable and return its stack offset
int addLocalVariable(const char* name, int size) {
    if (localVarCount >= MAX_LOCALS) {
        fprintf(stderr, "Error: Too many local variables\n");
        exit(1);
    }
    
    stackSize += size;
    localVars[localVarCount].name = strdup(name);
    localVars[localVarCount].offset = stackSize;
    localVarCount++;
    
    return stackSize;
}

// Get the stack offset for a variable
int getVariableOffset(const char* name) {
    for (int i = 0; i < localVarCount; i++) {
        if (strcmp(localVars[i].name, name) == 0) {
            return localVars[i].offset;
        }
    }
      // Variable not found - might be a global
    return 0;
}

// Check if a variable is a parameter (parameters have negative offsets)
int isParameter(const char* name) {
    for (int i = 0; i < localVarCount; i++) {
        if (strcmp(localVars[i].name, name) == 0) {
            return localVars[i].offset < 0;
        }
    }
    return 0;
}

// Initialize code generator
void initCodeGen(const char* outputFilename) {
    asmFile = fopen(outputFilename, "w");
    if (!asmFile) {
        fprintf(stderr, "Error: Could not open output file %s\n", outputFilename);
        exit(1);
    }
    labelCounter = 0;
    stringLiteralCount = 0;
    stringLiterals = NULL;
}

// Close code generator
void finalizeCodeGen() {
    if (asmFile) {
        // Generate string literals section before closing
        generateStringLiteralsSection();
        
        // Free string literals
        for (int i = 0; i < stringLiteralCount; i++) {
            if (stringLiterals[i]) {
                free(stringLiterals[i]);
            }
        }
        free(stringLiterals);
        fclose(asmFile);
        asmFile = NULL;
    }
}

// Generate a unique label ID
int getNextLabelId() {
    return labelCounter++;
}

// Generate a label with prefix
char* generateLabel(const char* prefix) {
    char* label = malloc(strlen(prefix) + 10);
    sprintf(label, "%s%d", prefix, getNextLabelId());
    return label;
}

void generateGlobalDeclaration(ASTNode* node);
void generateFunction(ASTNode* node);
void generateBlock(ASTNode* node);
void generateStatement(ASTNode* node);
void generateVariableDeclaration(ASTNode* node);
void generateExpression(ASTNode* node);
void generateBinaryOp(ASTNode* node);
void generateReturnStatement(ASTNode* node);
void generateFunctionCall(ASTNode* node);
void generateAsmBlock(ASTNode* node);
void generateAsmStmt(ASTNode* node);
void generateForLoop(ASTNode* node);

// Generate the header for the program
void generateProgramHeader() {
    fprintf(asmFile, "; 8086 Assembly generated by NCC Compiler\n");
    fprintf(asmFile, "bits 16\n\n");
    // No program entry point boilerplate for flat binary
}

// Main code generation function
void generateCode(ASTNode* root) {
    if (!root) {
        fprintf(stderr, "Error: Empty AST\n");
        return;
    }
      // Debug message removed to reduce output verbosity
    
    // Start with program header
    generateProgramHeader();
    
    // Process the AST - starting from the program node
    if (root->type == NODE_PROGRAM) {
        // Debug message removed to reduce output verbosity
          // Process all top-level declarations and functions
        ASTNode* current = root->left;
          if (!current) {
            fprintf(stderr, "Warning: Program node has no children (empty program)\n");
        }
        
        int nodeCount = 0;
        while (current) {
            nodeCount++;
              switch (current->type) {
                case NODE_FUNCTION:
                    // Debug message removed to reduce output verbosity
                    generateFunction(current);
                    break;
                case NODE_DECLARATION:
                    // Debug message removed to reduce output verbosity 
                    generateGlobalDeclaration(current);
                    break;
                default:
                    fprintf(stderr, "Warning: Unsupported top-level node type: %d\n", current->type);
            }
            current = current->next;
        }
    }
}

// Generate code for a function
void generateFunction(ASTNode* node) {
    if (!node || node->type != NODE_FUNCTION) return;
    
    // Clear any local variables from previous functions
    clearLocalVars();
    
    char* funcName = node->function.func_name;
    currentFunction = funcName;
    
    fprintf(asmFile, "; Function: %s\n", funcName);
    fprintf(asmFile, "_%s:\n", funcName);  // Prepend underscore to function names
    
    // Check if this function uses stackframe
    if (node->function.info.is_stackframe) {
        fprintf(asmFile, "    ; Setup stackframe with register preservation\n");
        fprintf(asmFile, "    push bp\n");
        fprintf(asmFile, "    mov bp, sp\n");
        fprintf(asmFile, "    push bx\n");
        fprintf(asmFile, "    push cx\n");
        fprintf(asmFile, "    push dx\n");
        fprintf(asmFile, "    push si\n");
        fprintf(asmFile, "    push di\n");
        
        // We'll calculate the actual space needed after processing all declarations
        fprintf(asmFile, "    ; Space for local variables will be allocated later\n\n");
    } else {
        // Standard function prologue
        fprintf(asmFile, "    push bp\n");
        fprintf(asmFile, "    mov bp, sp\n\n");
    }
    
    // Add function parameters to local variable table
    // Parameters start at bp+4 (return address is at bp+2)
    int paramOffset = 4;
    ASTNode* param = node->function.params;
    while (param) {
        // Parameters are accessed via positive offsets from bp
        if (param->type == NODE_DECLARATION) {
            // Store parameters in reverse order for easier access
            localVars[localVarCount].name = strdup(param->declaration.var_name);
            localVars[localVarCount].offset = -paramOffset; // Negative offset means it's a parameter
            localVarCount++;
            
            // Parameters always take 2 bytes on the stack in 16-bit mode
            paramOffset += 2;
        }
        param = param->next;
    }
    
    // Generate code for function body
    if (node->function.body) {
        generateBlock(node->function.body);
    }
    
    // Generate function exit label
    fprintf(asmFile, "\n_%s_exit:\n", funcName);
    
    // Function epilogue
    if (node->function.info.is_stackframe) {
        fprintf(asmFile, "    ; Restore stackframe with registers\n");
        
        // If we allocated space for locals, deallocate it here
        if (stackSize > 0) {
            fprintf(asmFile, "    add sp, %d ; Remove space for local variables\n", stackSize);
        }
        
        fprintf(asmFile, "    mov sp, bp\n");
        fprintf(asmFile, "    pop di\n");
        fprintf(asmFile, "    pop si\n");
        fprintf(asmFile, "    pop dx\n");
        fprintf(asmFile, "    pop cx\n");
        fprintf(asmFile, "    pop bx\n");
        fprintf(asmFile, "    pop bp\n");
    } else {
        fprintf(asmFile, "    ; Standard function epilogue\n");
        fprintf(asmFile, "    mov sp, bp\n");
        fprintf(asmFile, "    pop bp\n");
    }
    
    fprintf(asmFile, "    ret\n\n");
    
    currentFunction = NULL;
}

// Generate code for a block of statements
void generateBlock(ASTNode* node) {
    if (!node || node->type != NODE_BLOCK) return;
    
    ASTNode* statement = node->left;
    
    while (statement) {
        generateStatement(statement);
        statement = statement->next;
    }
}

// Generate code for a statement
void generateStatement(ASTNode* node) {
    if (!node) return;
    
    switch (node->type) {
        case NODE_DECLARATION:
            generateVariableDeclaration(node);
            break;
              case NODE_ASSIGNMENT:            fprintf(asmFile, "    ; Assignment statement\n");
            // Generate code for right-hand side
            generateExpression(node->right);
            
            // Store value in AX to the left-hand side
            if (node->left->type == NODE_IDENTIFIER) {
                // Check if this is a parameter or local variable
                if (isParameter(node->left->identifier)) {
                    // Parameters have positive offsets from bp
                    fprintf(asmFile, "    mov [bp+%d], ax ; Store in parameter %s\n", 
                            -getVariableOffset(node->left->identifier), node->left->identifier);
                } else {
                    // Local variables have negative offsets from bp
                    fprintf(asmFile, "    mov [bp-%d], ax ; Store in local variable %s\n", 
                            getVariableOffset(node->left->identifier), node->left->identifier);
                }
            } 
            else if (node->left->type == NODE_UNARY_OP && node->left->unary_op.op == UNARY_DEREFERENCE) {
                // Check if this is an array access (a[i])
                if (isArrayAccess(node->left)) {
                    // This is an array assignment (arr[index] = value)
                    generateArrayAssignment(node->left, node->right);
                }
                else {
                    // Normal pointer assignment (e.g., *ptr = value)
                    // Save the right-hand side result temporarily
                    fprintf(asmFile, "    push ax ; Save right-hand side value\n");
                    
                    // Generate code to evaluate the pointer expression
                    generateExpression(node->left->right);
                    fprintf(asmFile, "    mov bx, ax ; Move pointer address to BX\n");
                    
                    // Restore the value and store through the pointer
                    fprintf(asmFile, "    pop ax ; Restore right-hand side value\n");
                    fprintf(asmFile, "    mov [bx], ax ; Store value through pointer\n");
                }
            }
            else {
                fprintf(stderr, "Warning: Unsupported assignment target\n");
            }
            break;
            
        case NODE_RETURN:
            generateReturnStatement(node);
            break;
            
        case NODE_EXPRESSION:
            // Generate code for the expression, but we don't need the result
            generateExpression(node->left);
            break;
              case NODE_ASM_BLOCK:
            generateAsmBlock(node);
            break;
            
        case NODE_ASM:
            generateAsmStmt(node);
            break;
            
        case NODE_FOR:
            generateForLoop(node);
            break;
            
        case NODE_WHILE:
            generateWhileLoop(node);
            break;
            
        case NODE_IF:
            generateIfStatement(node);
            break;
            
        default:
            fprintf(stderr, "Warning: Unsupported statement type: %d\n", node->type);
            break;
    }
}

// Generate code for variable declaration
void generateVariableDeclaration(ASTNode* node) {
    if (!node || node->type != NODE_DECLARATION) return;
    
    // For local variables, we'll allocate space on the stack
    fprintf(asmFile, "    ; Local variable declaration: %s\n", node->declaration.var_name);
    
    // Determine variable size based on type
    int varSize = 2; // Default for int, short
    if (node->declaration.type_info.type == TYPE_CHAR || 
        node->declaration.type_info.type == TYPE_UNSIGNED_CHAR) {
        varSize = 1;
    }
    
    // If there's an initializer, generate code for the assignment
    if (node->declaration.initializer) {
        // Generate the value
        generateExpression(node->declaration.initializer);
        // Store it on the stack
        fprintf(asmFile, "    push ax ; Initialize local variable\n");
    } else {
        // Just reserve space by pushing a zero
        fprintf(asmFile, "    push 0 ; Uninitialized local variable\n");
    }
    
    // Add to local variable table
    addLocalVariable(node->declaration.var_name, varSize);
}

// Generate code for global variable declaration
void generateGlobalDeclaration(ASTNode* node) {
    if (!node || node->type != NODE_DECLARATION) return;

    fprintf(asmFile, "; Global variable: %s\n", node->declaration.var_name);
    
    // Define the variable with a label
    fprintf(asmFile, "_%s:\n", node->declaration.var_name);
    
    // Initialize global variables
    if (node->declaration.initializer && node->declaration.initializer->type == NODE_LITERAL) {
        // Literal initializer
        switch (node->declaration.initializer->literal.data_type) {
            case TYPE_INT:
                fprintf(asmFile, "    dw %d ; Integer value\n\n", 
                    node->declaration.initializer->literal.int_value);
                break;
            case TYPE_CHAR:
                fprintf(asmFile, "    db '%c' ; Character value\n\n", 
                    node->declaration.initializer->literal.char_value);
                break;
            case TYPE_FAR_POINTER:
                // Far pointer is stored as offset (low word) followed by segment (high word)
                fprintf(asmFile, "    dw %d ; Offset\n", 
                    node->declaration.initializer->literal.offset);
                fprintf(asmFile, "    dw %d ; Segment\n\n", 
                    node->declaration.initializer->literal.segment);
                break;
            default:
                fprintf(asmFile, "    dw 0 ; Default initialization\n\n");
                break;
        }
    } else {
        // For arrays or non-literal initializers
        int size = 2; // Default size for integers
        if (node->declaration.type_info.type == TYPE_CHAR || 
            node->declaration.type_info.type == TYPE_UNSIGNED_CHAR) {
            size = 1;
        }
        
        if (node->declaration.type_info.is_array) {
            // Array
            fprintf(asmFile, "    times %d db 0 ; Array initialization\n\n", 
                node->declaration.type_info.array_size * size);
        } else {
            // Default for other types
            fprintf(asmFile, "    dw 0 ; Default initialization\n\n");
        }
    }
}

// Generate code for an expression
void generateExpression(ASTNode* node) {
    if (!node) return;
    
    switch (node->type) {
        case NODE_LITERAL:
            // Handle different literal types
            if (node->literal.data_type == TYPE_FAR_POINTER) {
                // Load segment into dx, offset into ax for far pointers
                fprintf(asmFile, "    mov dx, 0x%04X ; Segment\n", node->literal.segment);
                fprintf(asmFile, "    mov ax, 0x%04X ; Offset\n", node->literal.offset);            } else if (node->literal.data_type == TYPE_CHAR && node->literal.string_value) {
                // Add string to the string literals table and get its index
                int strIndex = addStringLiteral(node->literal.string_value);
                if (strIndex >= 0) {
                    // Load the address of the string into AX
                    fprintf(asmFile, "    ; String literal\n");
                    fprintf(asmFile, "    mov ax, string_%d ; Address of string\n", strIndex);
                } else {
                    fprintf(asmFile, "    ; Error processing string literal\n");
                    fprintf(asmFile, "    mov ax, 0\n");
                }
            } else {
                // For numbers, load the value into ax
                fprintf(asmFile, "    mov ax, %d ; Load literal\n", node->literal.int_value);
            }
            break;        case NODE_IDENTIFIER:
            // Check if this is a parameter or local variable
            if (isParameter(node->identifier)) {
                // Parameters have positive offsets from bp
                fprintf(asmFile, "    mov ax, [bp+%d] ; Load parameter %s\n", 
                        -getVariableOffset(node->identifier), node->identifier);
            } else {
                // Local variables have negative offsets from bp
                fprintf(asmFile, "    mov ax, [bp-%d] ; Load local variable %s\n", 
                        getVariableOffset(node->identifier), node->identifier);
            }
            break;
              case NODE_BINARY_OP:
            // Generate code for binary operation
            generateBinaryOp(node);
            break;
              case NODE_UNARY_OP:
            // Check if this is an array access
            if (isArrayAccess(node)) {
                // Extract array and index expressions from the representation
                ASTNode* addNode = node->right;
                ASTNode* array = addNode->left;
                ASTNode* index = addNode->right;
                
                // Generate the array access code
                generateArrayAccess(array, index);
            } else {
                // Regular unary operation
                generateUnaryOp(node);
            }
            break;
            
        case NODE_CALL:
            // Generate function call
            generateFunctionCall(node);
            break;
            
        default:
            fprintf(stderr, "Warning: Unsupported expression type: %d\n", node->type);
            break;
    }
}

// Remove this block since we now have proper includes

// This will be moved to pointer_ops.c and included from there

// Generate code for binary operations
void generateBinaryOp(ASTNode* node) {
    // Check for pointer arithmetic first
    int leftIsPointer = isPointerType(node->left);
    int rightIsPointer = isPointerType(node->right);
    
    // Handle pointer arithmetic cases
    if ((leftIsPointer && (node->operation.op == OP_ADD || node->operation.op == OP_SUB)) ||
        ((leftIsPointer || rightIsPointer) && 
         (node->operation.op >= OP_EQ && node->operation.op <= OP_GTE))) {
        
        if (node->operation.op == OP_ADD || node->operation.op == OP_SUB) {
            // Pointer arithmetic
            generatePointerArithmetic(node->left, node->right, node->operation.op);
            return;
        }
        else {
            // Pointer comparison
            generatePointerComparison(node->left, node->right, node->operation.op);
            return;
        }
    }
    
    // Regular binary operation (non-pointer)
    // Generate left operand, save result on stack
    generateExpression(node->left);
    fprintf(asmFile, "    push ax ; Save left operand\n");
    
    // Generate right operand, result in ax
    generateExpression(node->right);
    
    // Move right operand to bx and restore left operand to ax
    fprintf(asmFile, "    mov bx, ax ; Right operand to bx\n");
    fprintf(asmFile, "    pop ax ; Restore left operand\n");
    
    // Perform operation based on operator type
    switch (node->operation.op) {
        case OP_ADD:
            fprintf(asmFile, "    add ax, bx ; Addition\n");
            break;
        case OP_SUB:
            fprintf(asmFile, "    sub ax, bx ; Subtraction\n");
            break;
        case OP_MUL:
            fprintf(asmFile, "    imul bx ; Multiplication (signed)\n");
            break;        case OP_DIV:
            // Use type-aware division function
            generateDivision(node->left, node->right, 0);  // 0 = not modulo
            break;
        case OP_MOD:
            // Use type-aware division function for modulo
            generateDivision(node->left, node->right, 1);  // 1 = modulo operation
            break;
              // Comparison operators for 8086 (without setcc instructions)
        case OP_EQ:
            fprintf(asmFile, "    cmp ax, bx ; Equal comparison\n");
            fprintf(asmFile, "    mov ax, 0  ; Assume false\n");
            fprintf(asmFile, "    je eq_true_%d\n", labelCounter);
            fprintf(asmFile, "    jmp eq_end_%d\n", labelCounter);
            fprintf(asmFile, "eq_true_%d:\n", labelCounter);
            fprintf(asmFile, "    mov ax, 1  ; Set true\n");
            fprintf(asmFile, "eq_end_%d:\n", labelCounter++);
            break;
        case OP_NEQ:
            fprintf(asmFile, "    cmp ax, bx ; Not equal comparison\n");
            fprintf(asmFile, "    mov ax, 0  ; Assume false\n");
            fprintf(asmFile, "    jne neq_true_%d\n", labelCounter);
            fprintf(asmFile, "    jmp neq_end_%d\n", labelCounter);
            fprintf(asmFile, "neq_true_%d:\n", labelCounter);
            fprintf(asmFile, "    mov ax, 1  ; Set true\n");
            fprintf(asmFile, "neq_end_%d:\n", labelCounter++);
            break;
        case OP_LT:
            fprintf(asmFile, "    cmp ax, bx ; Less than comparison\n");
            fprintf(asmFile, "    mov ax, 0  ; Assume false\n");
            fprintf(asmFile, "    jl lt_true_%d\n", labelCounter);
            fprintf(asmFile, "    jmp lt_end_%d\n", labelCounter);
            fprintf(asmFile, "lt_true_%d:\n", labelCounter);
            fprintf(asmFile, "    mov ax, 1  ; Set true\n");
            fprintf(asmFile, "lt_end_%d:\n", labelCounter++);
            break;
        case OP_LTE:
            fprintf(asmFile, "    cmp ax, bx ; Less than or equal comparison\n");
            fprintf(asmFile, "    mov ax, 0  ; Assume false\n");
            fprintf(asmFile, "    jle lte_true_%d\n", labelCounter);
            fprintf(asmFile, "    jmp lte_end_%d\n", labelCounter);
            fprintf(asmFile, "lte_true_%d:\n", labelCounter);
            fprintf(asmFile, "    mov ax, 1  ; Set true\n");
            fprintf(asmFile, "lte_end_%d:\n", labelCounter++);
            break;
        case OP_GT:
            fprintf(asmFile, "    cmp ax, bx ; Greater than comparison\n");
            fprintf(asmFile, "    mov ax, 0  ; Assume false\n");
            fprintf(asmFile, "    jg gt_true_%d\n", labelCounter);
            fprintf(asmFile, "    jmp gt_end_%d\n", labelCounter);
            fprintf(asmFile, "gt_true_%d:\n", labelCounter);
            fprintf(asmFile, "    mov ax, 1  ; Set true\n");
            fprintf(asmFile, "gt_end_%d:\n", labelCounter++);
            break;
        case OP_GTE:
            fprintf(asmFile, "    cmp ax, bx ; Greater than or equal comparison\n");
            fprintf(asmFile, "    mov ax, 0  ; Assume false\n");
            fprintf(asmFile, "    jge gte_true_%d\n", labelCounter);
            fprintf(asmFile, "    jmp gte_end_%d\n", labelCounter);
            fprintf(asmFile, "gte_true_%d:\n", labelCounter);
            fprintf(asmFile, "    mov ax, 1  ; Set true\n");
            fprintf(asmFile, "gte_end_%d:\n", labelCounter++);
            break;
            
        default:
            fprintf(stderr, "Warning: Unsupported binary operator: %d\n", node->operation.op);
            break;
    }
}

// Generate code for a function call
void generateFunctionCall(ASTNode* node) {
    if (!node || node->type != NODE_CALL) return;
    
    fprintf(asmFile, "    ; Function call to %s\n", node->call.func_name);
    
    // Push arguments in reverse order
    int argCount = 0;
    ASTNode* arg = node->call.args;
    ASTNode* args[32]; // Maximum 32 arguments
    
    // Collect arguments in an array first
    while (arg) {
        args[argCount++] = arg;
        arg = arg->next;
    }
    
    // Push arguments in reverse order
    for (int i = argCount - 1; i >= 0; i--) {
        generateExpression(args[i]);
        fprintf(asmFile, "    push ax ; Argument %d\n", i + 1);
    }
    
    // Check if it's a far call
    // TODO: Add support for far calls with segment:offset addressing
    
    // Call the function
    fprintf(asmFile, "    call _%s\n", node->call.func_name);
    
    // Clean up stack (caller-cleanup convention)
    if (argCount > 0) {
        fprintf(asmFile, "    add sp, %d ; Remove arguments\n", argCount * 2);
    }
    
    // Result is already in ax
}

// Generate code for a return statement
void generateReturnStatement(ASTNode* node) {
    if (!node || node->type != NODE_RETURN) return;
    
    fprintf(asmFile, "    ; Return statement\n");
    
    // Generate code for return value if present
    if (node->return_stmt.expr) {
        generateExpression(node->return_stmt.expr);
        // Return value is now in AX
    }
    
    // Jump to function epilogue
    fprintf(asmFile, "    jmp _%s_exit\n", currentFunction);
}

// Generate code for an inline assembly block
void generateAsmBlock(ASTNode* node) {
    if (!node || node->type != NODE_ASM_BLOCK || !node->asm_block.code) return;
    
    fprintf(asmFile, "    ; Inline assembly block\n");
    fprintf(asmFile, "%s\n", node->asm_block.code);
}

// Generate code for an inline assembly statement
void generateAsmStmt(ASTNode* node) {
    if (!node || node->type != NODE_ASM || !node->asm_stmt.code) return;
    
    fprintf(asmFile, "    ; Inline assembly statement\n");
    fprintf(asmFile, "    %s\n", node->asm_stmt.code);
}