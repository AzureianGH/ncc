; 8086 Assembly generated by NCC Compiler
bits 16
org 0x8000

; Function: _after_diskload
__after_diskload:
    push bp
    mov bp, sp

    ; Function call to clearScreen
    call _clearScreen
    ; Function call to writeString
    ; String literal: NCC Bootloader\r\n
    mov ax, kernel_string_0 ; Address of string
    push ax ; Argument 1
    call _writeString
    add sp, 2 ; Remove arguments
    ; Function call to writeString
    ; String literal: Loading kernel...\r\n
    mov ax, kernel_string_1 ; Address of string
    push ax ; Argument 1
    call _writeString
    add sp, 2 ; Remove arguments
    ; Function call to writeString
    ; String literal: Integer to string: 
    mov ax, kernel_string_2 ; Address of string
    push ax ; Argument 1
    call _writeString
    add sp, 2 ; Remove arguments
    ; Function call to writeString
    ; Function call to stoa_hex
    mov ax, 4660 ; Load literal
    push ax ; Argument 1
    call _stoa_hex
    add sp, 2 ; Remove arguments
    push ax ; Argument 1
    call _writeString
    add sp, 2 ; Remove arguments
    ; Function call to haltForever
    call _haltForever

__after_diskload_exit:
    ; Standard function epilogue
    mov sp, bp
    pop bp
    ret

; Function: assert
_assert:
    push bp
    mov bp, sp

    ; If statement
    mov ax, [bp+4] ; Load parameter condition
    test ax, ax ; Test if AX is zero
    setz al ; Set AL to 1 if AX is zero, 0 otherwise
    movzx ax, al ; Zero-extend AL to AX
    test ax, ax
    jz if_end1
    ; If true branch
    ; Function call to writeString
    ; String literal: Assertion failed!\r\n
    mov ax, kernel_string_3 ; Address of string
    push ax ; Argument 1
    call _writeString
    add sp, 2 ; Remove arguments
    ; Function call to haltForever
    call _haltForever
if_end1:

_assert_exit:
    ; Standard function epilogue
    mov sp, bp
    pop bp
    ret

; Function: clearScreen
_clearScreen:
    push bp
    mov bp, sp

    ; Inline assembly statement
    mov ax, 0x0003
    ; Inline assembly statement
    int 0x10

_clearScreen_exit:
    ; Standard function epilogue
    mov sp, bp
    pop bp
    ret

; Function: haltForever
_haltForever:
    ; Naked function - no prologue generated
    ; Inline assembly statement
    cli
    ; Inline assembly statement
    hlt
    ; Inline assembly statement
    jmp _haltForever

_haltForever_exit:
    ; Naked function - no epilogue generated

; Function: writeChar
_writeChar:
    push bp
    mov bp, sp

    ; Inline assembly statement
    mov al, [bp+4]
    ; Inline assembly statement
    mov ah, 0x0E
    ; Inline assembly statement
    mov bx, 0x0007
    ; Inline assembly statement
    int 0x10

_writeChar_exit:
    ; Standard function epilogue
    mov sp, bp
    pop bp
    ret

; Function: writeString
_writeString:
    push bp
    mov bp, sp

    ; While loop
while_cond2:
    mov ax, [bp+4] ; Load parameter str
    ; Dereferencing pointer
    mov bx, ax ; Move pointer address to BX
    cmp bx, 0 ; Check for null pointer
    je null_ptr_deref_5
    xor ah, ah ; Clear high byte for char
    mov al, [bx] ; Load byte (char) from memory
    jmp ptr_deref_end_5
null_ptr_deref_5:
    ; Null pointer dereference detected
    mov ax, 0 ; Return 0 for null deref
ptr_deref_end_5:
    test ax, ax
    jz while_end4
while_body3:
    ; Loop body
    ; Function call to writeChar
    ; Postfix increment of parameter str
    mov ax, [bp+4] ; Load parameter value
    mov bx, ax ; Save original value to BX
    inc bx ; Increment value
    mov [bp+4], bx ; Store incremented value back
    ; Dereferencing pointer
    mov bx, ax ; Move address to BX
    cmp bx, 0 ; Check for null pointer
    je null_ptr_deref_6
    mov ax, [bx] ; Load word from memory
    jmp ptr_deref_end_6
null_ptr_deref_6:
    ; Null pointer dereference detected
    mov ax, 0 ; Return 0 for null deref
ptr_deref_end_6:
    push ax ; Argument 1
    call _writeChar
    add sp, 2 ; Remove arguments
    jmp while_cond2
while_end4:

_writeString_exit:
    ; Standard function epilogue
    mov sp, bp
    pop bp
    ret

; Function: enterVBEGraphicsMode
_enterVBEGraphicsMode:
    push bp
    mov bp, sp

    ; Inline assembly statement
    mov ax, 0x4F02
    ; Inline assembly statement
    mov bx, 0x118
    ; Inline assembly statement
    int 0x10

_enterVBEGraphicsMode_exit:
    ; Standard function epilogue
    mov sp, bp
    pop bp
    ret

; Function: strlen
_strlen:
    push bp
    mov bp, sp

    ; Local variable declaration: len
    mov ax, 0 ; Load literal
    push ax ; Initialize local variable
    ; While loop
while_cond7:
    mov ax, [bp+4] ; Load parameter str
    test ax, ax ; logical AND left test
    jz land_false10 ; left false, skip right
    mov ax, [bp+4] ; Load parameter str
    push ax ; Save left operand
    mov ax, [bp-2] ; Load local variable len
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    ; Dereferencing pointer
    mov bx, ax ; Move address to BX
    cmp bx, 0 ; Check for null pointer
    je null_ptr_deref_12
    xor ah, ah ; Clear high byte for char
    mov al, [bx] ; Load byte (char) from memory
    jmp ptr_deref_end_12
null_ptr_deref_12:
    ; Null pointer dereference detected
    mov ax, 0 ; Return 0 for null deref
ptr_deref_end_12:
    test ax, ax ; logical AND right test
    jz land_false10 ; right false, result false
    mov ax, 1 ; both true -> true
    jmp land_end11
land_false10:
    mov ax, 0 ; false
land_end11:
    test ax, ax
    jz while_end9
while_body8:
    ; Loop body
    ; Postfix increment of variable len
    mov ax, [bp-2] ; Load variable value
    mov bx, ax ; Save original value to BX
    inc bx ; Increment value
    mov [bp-2], bx ; Store incremented value back
    jmp while_cond7
while_end9:
    ; Return statement
    mov ax, [bp-2] ; Load local variable len
    jmp _strlen_exit

_strlen_exit:
    ; Standard function epilogue
    mov sp, bp
    pop bp
    ret

; Function: stoa
_stoa:
    push bp
    mov bp, sp

    ; Array variable without initializers: buffer[20]
    ; Setting up pointer to array buffer[20]
    mov ax, _kernel_stoa_buffer_0 ; Address of array
    push ax ; Store pointer to array
    ; Local variable declaration: j
    mov ax, 0 ; Load literal
    push ax ; Initialize local variable
    ; If statement
    mov ax, [bp+4] ; Load parameter i
    push ax ; Save left operand
    mov ax, 0 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    cmp ax, bx ; Less than comparison
    mov ax, 0  ; Assume false
    jl lt_true_15
    jmp lt_end_15
lt_true_15:
    mov ax, 1  ; Set true
lt_end_15:
    test ax, ax
    jz if_end14
    ; If true branch
    ; Assignment statement
    mov ax, 45 ; Load literal
    push ax ; Save right-hand side value
    mov ax, [bp-2] ; Load local variable buffer
    push ax ; Save left operand
    ; Postfix increment of variable j
    mov ax, [bp-4] ; Load variable value
    mov bx, ax ; Save original value to BX
    inc bx ; Increment value
    mov [bp-4], bx ; Store incremented value back
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
    ; Assignment statement
    mov ax, [bp+4] ; Load parameter i
    neg ax ; Negate value
    mov [bp+4], ax ; Store in parameter i
if_end14:
    ; If statement
    mov ax, [bp+4] ; Load parameter i
    push ax ; Save left operand
    mov ax, 0 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    cmp ax, bx ; Equal comparison
    mov ax, 0  ; Assume false
    je eq_true_18
    jmp eq_end_18
eq_true_18:
    mov ax, 1  ; Set true
eq_end_18:
    test ax, ax
    jz if_else16
    ; If true branch
    ; Assignment statement
    mov ax, 48 ; Load literal
    push ax ; Save right-hand side value
    mov ax, [bp-2] ; Load local variable buffer
    push ax ; Save left operand
    ; Postfix increment of variable j
    mov ax, [bp-4] ; Load variable value
    mov bx, ax ; Save original value to BX
    inc bx ; Increment value
    mov [bp-4], bx ; Store incremented value back
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
    jmp if_end17
if_else16:
    ; Else branch
    ; Local variable declaration: k
    mov ax, [bp+4] ; Load parameter i
    push ax ; Initialize local variable
    ; While loop
while_cond19:
    mov ax, [bp-6] ; Load local variable k
    push ax ; Save left operand
    mov ax, 0 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    cmp ax, bx ; Greater than comparison
    mov ax, 0  ; Assume false
    jg gt_true_22
    jmp gt_end_22
gt_true_22:
    mov ax, 1  ; Set true
gt_end_22:
    test ax, ax
    jz while_end21
while_body20:
    ; Loop body
    ; Assignment statement
    mov ax, [bp-6] ; Load local variable k for compound assignment
    push ax ; Save old value
    mov ax, 10 ; Load literal
    push ax ; Save RHS value
    pop bx ; RHS value
    pop ax ; Old LHS value
    cwd ; Sign extend AX into DX:AX for division
    idiv bx ; /=
    mov [bp-6], ax ; Store in local variable k
    ; Postfix increment of variable j
    mov ax, [bp-4] ; Load variable value
    mov bx, ax ; Save original value to BX
    inc bx ; Increment value
    mov [bp-4], bx ; Store incremented value back
    jmp while_cond19
while_end21:
    ; Assignment statement
    mov ax, 0 ; Load literal
    push ax ; Save right-hand side value
    mov ax, [bp-2] ; Load local variable buffer
    push ax ; Save left operand
    mov ax, [bp-4] ; Load local variable j
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
    ; While loop
while_cond23:
    mov ax, [bp+4] ; Load parameter i
    push ax ; Save left operand
    mov ax, 0 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    cmp ax, bx ; Greater than comparison
    mov ax, 0  ; Assume false
    jg gt_true_26
    jmp gt_end_26
gt_true_26:
    mov ax, 1  ; Set true
gt_end_26:
    test ax, ax
    jz while_end25
while_body24:
    ; Loop body
    ; Assignment statement
    mov ax, [bp+4] ; Load parameter i
    push ax ; Save left operand
    mov ax, 10 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    cwd ; Sign extend AX into DX:AX for signed mod
    idiv bx ; Division (signed)
    mov ax, dx ; Remainder is in DX
    push ax ; Save left operand
    mov ax, 48 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    push ax ; Save right-hand side value
    mov ax, [bp-2] ; Load local variable buffer
    push ax ; Save left operand
    ; Prefix decrement of variable j
    mov ax, [bp-4] ; Load variable value
    dec ax ; Decrement value
    mov [bp-4], ax ; Store decremented value back
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
    ; Assignment statement
    mov ax, [bp+4] ; Load parameter i for compound assignment
    push ax ; Save old value
    mov ax, 10 ; Load literal
    push ax ; Save RHS value
    pop bx ; RHS value
    pop ax ; Old LHS value
    cwd ; Sign extend AX into DX:AX for division
    idiv bx ; /=
    mov [bp+4], ax ; Store in parameter i
    jmp while_cond23
while_end25:
if_end17:
    ; Return statement
    mov ax, [bp-2] ; Load local variable buffer
    jmp _stoa_exit

_stoa_exit:
    ; Standard function epilogue
    mov sp, bp
    pop bp
    ret

; Function: stoa_hex
_stoa_hex:
    push bp
    mov bp, sp

    ; Array variable without initializers: buffer[7]
    ; Setting up pointer to array buffer[7]
    mov ax, _kernel_stoa_hex_buffer_1 ; Address of array
    push ax ; Store pointer to array
    ; Assignment statement
    mov ax, 48 ; Load literal
    push ax ; Save right-hand side value
    mov ax, [bp-2] ; Load local variable buffer
    push ax ; Save left operand
    mov ax, 0 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
    ; Assignment statement
    mov ax, 120 ; Load literal
    push ax ; Save right-hand side value
    mov ax, [bp-2] ; Load local variable buffer
    push ax ; Save left operand
    mov ax, 1 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
    ; Assignment statement
    mov ax, 0 ; Load literal
    push ax ; Save right-hand side value
    mov ax, [bp-2] ; Load local variable buffer
    push ax ; Save left operand
    mov ax, 6 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
    ; Assignment statement
    mov ax, [bp+4] ; Load parameter i
    push ax ; Save left operand
    mov ax, 15 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    and ax, bx ; Bitwise AND
    push ax ; Save left operand
    mov ax, 48 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    push ax ; Save right-hand side value
    mov ax, [bp-2] ; Load local variable buffer
    push ax ; Save left operand
    mov ax, 5 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
    ; If statement
    ; Array variable buffer
    mov bx, [bp-2] ; Load array address
    ; Access byte element [5]
    mov al, [bx+5] ; Load byte
    xor ah, ah ; Clear high byte
    push ax ; Save left operand
    mov ax, 57 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    cmp ax, bx ; Greater than comparison
    mov ax, 0  ; Assume false
    jg gt_true_29
    jmp gt_end_29
gt_true_29:
    mov ax, 1  ; Set true
gt_end_29:
    test ax, ax
    jz if_end28
    ; If true branch
    ; Assignment statement
    mov ax, 7 ; Load literal
    push ax ; Save right-hand side value
    mov ax, [bp-2] ; Load local variable buffer
    push ax ; Save left operand
    mov ax, 5 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
if_end28:
    ; Assignment statement
    mov ax, [bp+4] ; Load parameter i
    push ax ; Save left operand
    mov ax, 4 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    mov cx, bx ; Set shift count in CX
    sar ax, cl ; Shift right (arithmetic, preserves sign)
    push ax ; Save left operand
    mov ax, 15 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    and ax, bx ; Bitwise AND
    push ax ; Save left operand
    mov ax, 48 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    push ax ; Save right-hand side value
    mov ax, [bp-2] ; Load local variable buffer
    push ax ; Save left operand
    mov ax, 4 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
    ; If statement
    ; Array variable buffer
    mov bx, [bp-2] ; Load array address
    ; Access byte element [4]
    mov al, [bx+4] ; Load byte
    xor ah, ah ; Clear high byte
    push ax ; Save left operand
    mov ax, 57 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    cmp ax, bx ; Greater than comparison
    mov ax, 0  ; Assume false
    jg gt_true_32
    jmp gt_end_32
gt_true_32:
    mov ax, 1  ; Set true
gt_end_32:
    test ax, ax
    jz if_end31
    ; If true branch
    ; Assignment statement
    mov ax, 7 ; Load literal
    push ax ; Save right-hand side value
    mov ax, [bp-2] ; Load local variable buffer
    push ax ; Save left operand
    mov ax, 4 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
if_end31:
    ; Assignment statement
    mov ax, [bp+4] ; Load parameter i
    push ax ; Save left operand
    mov ax, 8 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    mov cx, bx ; Set shift count in CX
    sar ax, cl ; Shift right (arithmetic, preserves sign)
    push ax ; Save left operand
    mov ax, 15 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    and ax, bx ; Bitwise AND
    push ax ; Save left operand
    mov ax, 48 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    push ax ; Save right-hand side value
    mov ax, [bp-2] ; Load local variable buffer
    push ax ; Save left operand
    mov ax, 3 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
    ; If statement
    ; Array variable buffer
    mov bx, [bp-2] ; Load array address
    ; Access byte element [3]
    mov al, [bx+3] ; Load byte
    xor ah, ah ; Clear high byte
    push ax ; Save left operand
    mov ax, 57 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    cmp ax, bx ; Greater than comparison
    mov ax, 0  ; Assume false
    jg gt_true_35
    jmp gt_end_35
gt_true_35:
    mov ax, 1  ; Set true
gt_end_35:
    test ax, ax
    jz if_end34
    ; If true branch
    ; Assignment statement
    mov ax, 7 ; Load literal
    push ax ; Save right-hand side value
    mov ax, [bp-2] ; Load local variable buffer
    push ax ; Save left operand
    mov ax, 3 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
if_end34:
    ; Assignment statement
    mov ax, [bp+4] ; Load parameter i
    push ax ; Save left operand
    mov ax, 12 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    mov cx, bx ; Set shift count in CX
    sar ax, cl ; Shift right (arithmetic, preserves sign)
    push ax ; Save left operand
    mov ax, 15 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    and ax, bx ; Bitwise AND
    push ax ; Save left operand
    mov ax, 48 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    push ax ; Save right-hand side value
    mov ax, [bp-2] ; Load local variable buffer
    push ax ; Save left operand
    mov ax, 2 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
    ; If statement
    ; Array variable buffer
    mov bx, [bp-2] ; Load array address
    ; Access byte element [2]
    mov al, [bx+2] ; Load byte
    xor ah, ah ; Clear high byte
    push ax ; Save left operand
    mov ax, 57 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    cmp ax, bx ; Greater than comparison
    mov ax, 0  ; Assume false
    jg gt_true_38
    jmp gt_end_38
gt_true_38:
    mov ax, 1  ; Set true
gt_end_38:
    test ax, ax
    jz if_end37
    ; If true branch
    ; Assignment statement
    mov ax, 7 ; Load literal
    push ax ; Save right-hand side value
    mov ax, [bp-2] ; Load local variable buffer
    push ax ; Save left operand
    mov ax, 2 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
if_end37:
    ; Return statement
    mov ax, [bp-2] ; Load local variable buffer
    jmp _stoa_hex_exit

_stoa_hex_exit:
    ; Standard function epilogue
    mov sp, bp
    pop bp
    ret


; Data section for strings and arrays
; String literals section
kernel_string_0: db 78, 67, 67, 32, 66, 111, 111, 116, 108, 111, 97, 100, 101, 114, 13, 10, 0  ; null terminator
kernel_string_1: db 76, 111, 97, 100, 105, 110, 103, 32, 107, 101, 114, 110, 101, 108, 46, 46, 46, 13, 10, 0  ; null terminator
kernel_string_2: db 73, 110, 116, 101, 103, 101, 114, 32, 116, 111, 32, 115, 116, 114, 105, 110, 103, 58, 32, 0  ; null terminator
kernel_string_3: db 65, 115, 115, 101, 114, 116, 105, 111, 110, 32, 102, 97, 105, 108, 101, 100, 33, 13, 10, 0  ; null terminator

; Array declarations section
_kernel_stoa_buffer_0: times 20 db 0 ; Array of 20 bytes
_kernel_stoa_hex_buffer_1: times 7 db 0 ; Array of 7 bytes
