; 8086 Assembly generated by NCC Compiler
bits 16
org 0x0

; Function: _after_diskload
__after_diskload:
    push bp
    mov bp, sp

    ; Function call to clearScreen
    call _clearScreen
    ; Function call to writeString
    ; String literal: NCC Bootloader\r\n
    mov ax, test_casting_string_0 ; Address of string
    push ax ; Argument 1
    call _writeString
    add sp, 2 ; Remove arguments
    ; Function call to writeString
    ; String literal: Loading kernel...\r\n
    mov ax, test_casting_string_1 ; Address of string
    push ax ; Argument 1
    call _writeString
    add sp, 2 ; Remove arguments
    ; Local variable declaration: testValue
    mov ax, 5 ; Load literal
    neg ax ; Negate value
    push ax ; Initialize local variable
    ; Function call to writeString
    ; String literal: Signed value: 
    mov ax, test_casting_string_2 ; Address of string
    push ax ; Argument 1
    call _writeString
    add sp, 2 ; Remove arguments
    ; Function call to stoa_dec
    ; Loading potentially global variable dec_buffer
    mov ax, [_test_casting_dec_buffer] ; Load global variable
    push ax ; Argument 2
    mov ax, [bp-2] ; Load local variable testValue
    push ax ; Argument 1
    call _stoa_dec
    add sp, 4 ; Remove arguments
    ; Function call to writeString
    ; Loading potentially global variable dec_buffer
    mov ax, [_test_casting_dec_buffer] ; Load global variable
    push ax ; Argument 1
    call _writeString
    add sp, 2 ; Remove arguments
    ; Function call to writeString
    ; String literal: \r\n
    mov ax, test_casting_string_3 ; Address of string
    push ax ; Argument 1
    call _writeString
    add sp, 2 ; Remove arguments
    ; Function call to writeString
    ; String literal: Unsigned cast: 
    mov ax, test_casting_string_4 ; Address of string
    push ax ; Argument 1
    call _writeString
    add sp, 2 ; Remove arguments
    ; Function call to stoa_dec
    ; Loading potentially global variable dec_buffer
    mov ax, [_test_casting_dec_buffer] ; Load global variable
    push ax ; Argument 2
    mov ax, [bp-2] ; Load local variable testValue
    ; Cast to unsigned int/short
    push ax ; Argument 1
    call _stoa_dec
    add sp, 4 ; Remove arguments
    ; Function call to writeString
    ; Loading potentially global variable dec_buffer
    mov ax, [_test_casting_dec_buffer] ; Load global variable
    push ax ; Argument 1
    call _writeString
    add sp, 2 ; Remove arguments
    ; Function call to writeString
    ; String literal: \r\n
    mov ax, test_casting_string_5 ; Address of string
    push ax ; Argument 1
    call _writeString
    add sp, 2 ; Remove arguments
    ; Local variable declaration: largeNeg
    mov ax, 32000 ; Load literal
    neg ax ; Negate value
    push ax ; Initialize local variable
    ; Function call to writeString
    ; String literal: Large negative: 
    mov ax, test_casting_string_6 ; Address of string
    push ax ; Argument 1
    call _writeString
    add sp, 2 ; Remove arguments
    ; Function call to stoa_dec
    ; Loading potentially global variable dec_buffer
    mov ax, [_test_casting_dec_buffer] ; Load global variable
    push ax ; Argument 2
    mov ax, [bp-4] ; Load local variable largeNeg
    push ax ; Argument 1
    call _stoa_dec
    add sp, 4 ; Remove arguments
    ; Function call to writeString
    ; Loading potentially global variable dec_buffer
    mov ax, [_test_casting_dec_buffer] ; Load global variable
    push ax ; Argument 1
    call _writeString
    add sp, 2 ; Remove arguments
    ; Function call to writeString
    ; String literal: \r\n
    mov ax, test_casting_string_7 ; Address of string
    push ax ; Argument 1
    call _writeString
    add sp, 2 ; Remove arguments
    ; Function call to writeString
    ; String literal: Large unsigned: 
    mov ax, test_casting_string_8 ; Address of string
    push ax ; Argument 1
    call _writeString
    add sp, 2 ; Remove arguments
    ; Function call to stoa_dec
    ; Loading potentially global variable dec_buffer
    mov ax, [_test_casting_dec_buffer] ; Load global variable
    push ax ; Argument 2
    mov ax, [bp-4] ; Load local variable largeNeg
    ; Cast to unsigned int/short
    push ax ; Argument 1
    call _stoa_dec
    add sp, 4 ; Remove arguments
    ; Function call to writeString
    ; Loading potentially global variable dec_buffer
    mov ax, [_test_casting_dec_buffer] ; Load global variable
    push ax ; Argument 1
    call _writeString
    add sp, 2 ; Remove arguments
    ; Function call to writeString
    ; String literal: \r\n
    mov ax, test_casting_string_9 ; Address of string
    push ax ; Argument 1
    call _writeString
    add sp, 2 ; Remove arguments
    ; Function call to haltForever
    call _haltForever

__after_diskload_exit:
    ; Standard function epilogue
    mov sp, bp
    pop bp
    ret

; Function: assert
_assert:
    push bp
    mov bp, sp

    ; If statement
    mov ax, [bp+4] ; Load parameter condition
    test ax, ax ; Test if AX is zero
    setz al ; Set AL to 1 if AX is zero, 0 otherwise
    movzx ax, al ; Zero-extend AL to AX
    test ax, ax
    jz if_end1
    ; If true branch
    ; Function call to writeString
    ; String literal: Assertion failed!\r\n
    mov ax, test_casting_string_10 ; Address of string
    push ax ; Argument 1
    call _writeString
    add sp, 2 ; Remove arguments
    ; Function call to haltForever
    call _haltForever
if_end1:

_assert_exit:
    ; Standard function epilogue
    mov sp, bp
    pop bp
    ret

; Function: clearScreen
_clearScreen:
    push bp
    mov bp, sp

    ; Inline assembly statement
    mov ax, 0x0003
    ; Inline assembly statement
    int 0x10

_clearScreen_exit:
    ; Standard function epilogue
    mov sp, bp
    pop bp
    ret

; Function: haltForever
_haltForever:
    ; Naked function - no prologue generated
    ; Inline assembly statement
    cli
    ; Inline assembly statement
    hlt
    ; Inline assembly statement
    jmp _haltForever

_haltForever_exit:
    ; Naked function - no epilogue generated

; Function: writeChar
_writeChar:
    push bp
    mov bp, sp

    ; Inline assembly statement
    mov al, [bp+4]
    ; Inline assembly statement
    mov ah, 0x0E
    ; Inline assembly statement
    mov bx, 0x0007
    ; Inline assembly statement
    int 0x10

_writeChar_exit:
    ; Standard function epilogue
    mov sp, bp
    pop bp
    ret

; Function: writeString
_writeString:
    push bp
    mov bp, sp

    ; While loop
while_cond2:
    mov ax, [bp+4] ; Load parameter str
    ; Dereferencing pointer
    mov bx, ax ; Move pointer address to BX
    cmp bx, 0 ; Check for null pointer
    je null_ptr_deref_5
    xor ah, ah ; Clear high byte for char
    mov al, [bx] ; Load byte (char) from memory
    jmp ptr_deref_end_5
null_ptr_deref_5:
    ; Null pointer dereference detected
    mov ax, 0 ; Return 0 for null deref
ptr_deref_end_5:
    test ax, ax
    jz while_end4
while_body3:
    ; Loop body
    ; Function call to writeChar
    ; Postfix increment of parameter str
    mov ax, [bp+4] ; Load parameter value
    mov bx, ax ; Save original value to BX
    inc bx ; Increment value
    mov [bp+4], bx ; Store incremented value back
    ; Dereferencing pointer
    mov bx, ax ; Move address to BX
    cmp bx, 0 ; Check for null pointer
    je null_ptr_deref_6
    mov ax, [bx] ; Load word from memory
    jmp ptr_deref_end_6
null_ptr_deref_6:
    ; Null pointer dereference detected
    mov ax, 0 ; Return 0 for null deref
ptr_deref_end_6:
    push ax ; Argument 1
    call _writeChar
    add sp, 2 ; Remove arguments
    jmp while_cond2
while_end4:

_writeString_exit:
    ; Standard function epilogue
    mov sp, bp
    pop bp
    ret

; Function: enterVBEGraphicsMode
_enterVBEGraphicsMode:
    push bp
    mov bp, sp

    ; Inline assembly statement
    mov ax, 0x4F02
    ; Inline assembly statement
    mov bx, 0x118
    ; Inline assembly statement
    int 0x10

_enterVBEGraphicsMode_exit:
    ; Standard function epilogue
    mov sp, bp
    pop bp
    ret

; Function: strlen
_strlen:
    push bp
    mov bp, sp

    ; Local variable declaration: len
    mov ax, 0 ; Load literal
    push ax ; Initialize local variable
    ; While loop
while_cond7:
    mov ax, [bp+4] ; Load parameter str
    test ax, ax ; logical AND left test
    jz land_false10 ; left false, skip right
    mov ax, [bp+4] ; Load parameter str
    push ax ; Save left operand
    mov ax, [bp-2] ; Load local variable len
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    ; Dereferencing pointer
    mov bx, ax ; Move address to BX
    cmp bx, 0 ; Check for null pointer
    je null_ptr_deref_12
    xor ah, ah ; Clear high byte for char
    mov al, [bx] ; Load byte (char) from memory
    jmp ptr_deref_end_12
null_ptr_deref_12:
    ; Null pointer dereference detected
    mov ax, 0 ; Return 0 for null deref
ptr_deref_end_12:
    test ax, ax ; logical AND right test
    jz land_false10 ; right false, result false
    mov ax, 1 ; both true -> true
    jmp land_end11
land_false10:
    mov ax, 0 ; false
land_end11:
    test ax, ax
    jz while_end9
while_body8:
    ; Loop body
    ; Postfix increment of variable len
    mov ax, [bp-2] ; Load variable value
    mov bx, ax ; Save original value to BX
    inc bx ; Increment value
    mov [bp-2], bx ; Store incremented value back
    jmp while_cond7
while_end9:
    ; Return statement
    mov ax, [bp-2] ; Load local variable len
    jmp _strlen_exit

_strlen_exit:
    ; Standard function epilogue
    mov sp, bp
    pop bp
    ret

; Function: stoa_hex
_stoa_hex:
    push bp
    mov bp, sp

    ; Local variable declaration: i
    mov ax, 0 ; Load literal
    push ax ; Initialize local variable
    ; Local variable declaration: temp
    mov ax, [bp+4] ; Load parameter value
    ; Cast to unsigned int/short
    push ax ; Initialize local variable
    ; If statement
    mov ax, [bp-4] ; Load local variable temp
    push ax ; Save left operand
    mov ax, 0 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    cmp ax, bx ; Equal comparison
    mov ax, 0  ; Assume false
    je eq_true_15
    jmp eq_end_15
eq_true_15:
    mov ax, 1  ; Set true
eq_end_15:
    test ax, ax
    jz if_else13
    ; If true branch
    ; Assignment statement
    mov ax, 48 ; Load literal
    push ax ; Save right-hand side value
    mov ax, [bp+6] ; Load parameter buffer
    push ax ; Save left operand
    ; Postfix increment of variable i
    mov ax, [bp-2] ; Load variable value
    mov bx, ax ; Save original value to BX
    inc bx ; Increment value
    mov [bp-2], bx ; Store incremented value back
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
    jmp if_end14
if_else13:
    ; Else branch
    ; While loop
while_cond16:
    mov ax, [bp-4] ; Load local variable temp
    push ax ; Save left operand
    mov ax, 0 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    cmp ax, bx ; Greater than comparison
    mov ax, 0  ; Assume false
    jg gt_true_19
    jmp gt_end_19
gt_true_19:
    mov ax, 1  ; Set true
gt_end_19:
    test ax, ax
    jz while_end18
while_body17:
    ; Loop body
    ; Local variable declaration: digit
    mov ax, [bp-4] ; Load local variable temp
    push ax ; Save left operand
    mov ax, 16 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    cwd ; Sign extend AX into DX:AX
    idiv bx ; Division (signed)
    mov ax, dx ; Remainder is in DX
    push ax ; Initialize local variable
    ; If statement
    mov ax, [bp-6] ; Load local variable digit
    push ax ; Save left operand
    mov ax, 10 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    cmp ax, bx ; Less than comparison
    mov ax, 0  ; Assume false
    jl lt_true_22
    jmp lt_end_22
lt_true_22:
    mov ax, 1  ; Set true
lt_end_22:
    test ax, ax
    jz if_else20
    ; If true branch
    ; Assignment statement
    mov ax, [bp-6] ; Load local variable digit
    push ax ; Save left operand
    mov ax, 48 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    push ax ; Save right-hand side value
    mov ax, [bp+6] ; Load parameter buffer
    push ax ; Save left operand
    ; Postfix increment of variable i
    mov ax, [bp-2] ; Load variable value
    mov bx, ax ; Save original value to BX
    inc bx ; Increment value
    mov [bp-2], bx ; Store incremented value back
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
    jmp if_end21
if_else20:
    ; Else branch
    ; Assignment statement
    mov ax, [bp-6] ; Load local variable digit
    push ax ; Save left operand
    mov ax, 10 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    sub ax, bx ; Subtraction
    mov [bp-6], ax ; Store in local variable digit
    ; Assignment statement
    mov ax, [bp-6] ; Load local variable digit
    push ax ; Save left operand
    mov ax, 65 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    push ax ; Save right-hand side value
    mov ax, [bp+6] ; Load parameter buffer
    push ax ; Save left operand
    ; Postfix increment of variable i
    mov ax, [bp-2] ; Load variable value
    mov bx, ax ; Save original value to BX
    inc bx ; Increment value
    mov [bp-2], bx ; Store incremented value back
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
if_end21:
    ; Assignment statement
    mov ax, [bp-4] ; Load local variable temp for compound assignment
    push ax ; Save old value
    mov ax, 16 ; Load literal
    push ax ; Save RHS value
    pop bx ; RHS value
    pop ax ; Old LHS value
    cwd ; Sign extend AX into DX:AX for division
    idiv bx ; /=
    mov [bp-4], ax ; Store in local variable temp
    jmp while_cond16
while_end18:
if_end14:
    ; Assignment statement
    mov ax, 120 ; Load literal
    push ax ; Save right-hand side value
    mov ax, [bp+6] ; Load parameter buffer
    push ax ; Save left operand
    ; Postfix increment of variable i
    mov ax, [bp-2] ; Load variable value
    mov bx, ax ; Save original value to BX
    inc bx ; Increment value
    mov [bp-2], bx ; Store incremented value back
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
    ; Assignment statement
    mov ax, 48 ; Load literal
    push ax ; Save right-hand side value
    mov ax, [bp+6] ; Load parameter buffer
    push ax ; Save left operand
    ; Postfix increment of variable i
    mov ax, [bp-2] ; Load variable value
    mov bx, ax ; Save original value to BX
    inc bx ; Increment value
    mov [bp-2], bx ; Store incremented value back
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
    ; Assignment statement
    mov ax, 0 ; Load literal
    push ax ; Save right-hand side value
    mov ax, [bp+6] ; Load parameter buffer
    push ax ; Save left operand
    mov ax, [bp-2] ; Load local variable i
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
    ; For loop
    ; For loop initialization
    ; Local variable declaration: j
    mov ax, 0 ; Load literal
    push ax ; Initialize local variable
    jmp for_cond24
for_start23:
    ; For loop body
    ; Local variable declaration: swap
    mov ax, [bp+6] ; Load parameter buffer
    push ax ; Save left operand
    mov ax, [bp-8] ; Load local variable j
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    ; Dereferencing pointer
    mov bx, ax ; Move address to BX
    cmp bx, 0 ; Check for null pointer
    je null_ptr_deref_27
    xor ah, ah ; Clear high byte for char
    mov al, [bx] ; Load byte (char) from memory
    jmp ptr_deref_end_27
null_ptr_deref_27:
    ; Null pointer dereference detected
    mov ax, 0 ; Return 0 for null deref
ptr_deref_end_27:
    push ax ; Initialize local variable
    ; Assignment statement
    mov ax, [bp+6] ; Load parameter buffer
    push ax ; Save left operand
    mov ax, [bp-2] ; Load local variable i
    push ax ; Save left operand
    mov ax, [bp-8] ; Load local variable j
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    sub ax, bx ; Subtraction
    push ax ; Save left operand
    mov ax, 1 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    sub ax, bx ; Subtraction
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    ; Dereferencing pointer
    mov bx, ax ; Move address to BX
    cmp bx, 0 ; Check for null pointer
    je null_ptr_deref_28
    xor ah, ah ; Clear high byte for char
    mov al, [bx] ; Load byte (char) from memory
    jmp ptr_deref_end_28
null_ptr_deref_28:
    ; Null pointer dereference detected
    mov ax, 0 ; Return 0 for null deref
ptr_deref_end_28:
    push ax ; Save right-hand side value
    mov ax, [bp+6] ; Load parameter buffer
    push ax ; Save left operand
    mov ax, [bp-8] ; Load local variable j
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
    ; Assignment statement
    mov ax, [bp-10] ; Load local variable swap
    push ax ; Save right-hand side value
    mov ax, [bp+6] ; Load parameter buffer
    push ax ; Save left operand
    mov ax, [bp-2] ; Load local variable i
    push ax ; Save left operand
    mov ax, [bp-8] ; Load local variable j
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    sub ax, bx ; Subtraction
    push ax ; Save left operand
    mov ax, 1 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    sub ax, bx ; Subtraction
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
for_update25:
    ; For loop update
    ; Postfix increment of variable j
    mov ax, [bp-8] ; Load variable value
    mov bx, ax ; Save original value to BX
    inc bx ; Increment value
    mov [bp-8], bx ; Store incremented value back
for_cond24:
    ; For loop condition
    mov ax, [bp-8] ; Load local variable j
    push ax ; Save left operand
    mov ax, [bp-2] ; Load local variable i
    push ax ; Save left operand
    mov ax, 2 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    cwd ; Sign extend AX into DX:AX
    idiv bx ; Division (signed)
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    cmp ax, bx ; Less than comparison
    mov ax, 0  ; Assume false
    jl lt_true_29
    jmp lt_end_29
lt_true_29:
    mov ax, 1  ; Set true
lt_end_29:
    test ax, ax
    jnz for_start23
for_end26:

_stoa_hex_exit:
    ; Standard function epilogue
    mov sp, bp
    pop bp
    ret

; Function: stoa_dec
_stoa_dec:
    push bp
    mov bp, sp

    ; Local variable declaration: i
    mov ax, 0 ; Load literal
    push ax ; Initialize local variable
    ; Local variable declaration: isNegative
    mov ax, 0 ; Load literal
    push ax ; Initialize local variable
    ; Local variable declaration: temp
    push 0 ; Uninitialized local variable
    ; If statement
    mov ax, [bp+4] ; Load parameter value
    push ax ; Save left operand
    mov ax, 0 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    cmp ax, bx ; Less than comparison
    mov ax, 0  ; Assume false
    jl lt_true_32
    jmp lt_end_32
lt_true_32:
    mov ax, 1  ; Set true
lt_end_32:
    test ax, ax
    jz if_else30
    ; If true branch
    ; Assignment statement
    mov ax, 1 ; Load literal
    mov [bp-4], ax ; Store in local variable isNegative
    ; Local variable declaration: negVal
    mov ax, [bp+4] ; Load parameter value
    neg ax ; Negate value
    push ax ; Initialize local variable
    ; Assignment statement
    mov ax, [bp-8] ; Load local variable negVal
    ; Cast to unsigned int/short
    mov [bp-6], ax ; Store in local variable temp
    jmp if_end31
if_else30:
    ; Else branch
    ; Assignment statement
    mov ax, [bp+4] ; Load parameter value
    ; Cast to unsigned int/short
    mov [bp-6], ax ; Store in local variable temp
if_end31:
    ; Do-while loop
do_body33:
    ; Loop body
    ; Local variable declaration: digit
    mov ax, [bp-6] ; Load local variable temp
    push ax ; Save left operand
    mov ax, 10 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    cwd ; Sign extend AX into DX:AX
    idiv bx ; Division (signed)
    mov ax, dx ; Remainder is in DX
    push ax ; Initialize local variable
    ; Assignment statement
    mov ax, [bp-10] ; Load local variable digit
    push ax ; Save left operand
    mov ax, 48 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    push ax ; Save right-hand side value
    mov ax, [bp+6] ; Load parameter buffer
    push ax ; Save left operand
    ; Postfix increment of variable i
    mov ax, [bp-2] ; Load variable value
    mov bx, ax ; Save original value to BX
    inc bx ; Increment value
    mov [bp-2], bx ; Store incremented value back
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
    ; Assignment statement
    mov ax, [bp-6] ; Load local variable temp for compound assignment
    push ax ; Save old value
    mov ax, 10 ; Load literal
    push ax ; Save RHS value
    pop bx ; RHS value
    pop ax ; Old LHS value
    cwd ; Sign extend AX into DX:AX for division
    idiv bx ; /=
    mov [bp-6], ax ; Store in local variable temp
do_cond34:
    mov ax, [bp-6] ; Load local variable temp
    push ax ; Save left operand
    mov ax, 0 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    cmp ax, bx ; Greater than comparison
    mov ax, 0  ; Assume false
    jg gt_true_36
    jmp gt_end_36
gt_true_36:
    mov ax, 1  ; Set true
gt_end_36:
    test ax, ax
    jnz do_body33
do_end35:
    ; If statement
    mov ax, [bp-4] ; Load local variable isNegative
    test ax, ax
    jz if_end38
    ; If true branch
    ; Assignment statement
    mov ax, 45 ; Load literal
    push ax ; Save right-hand side value
    mov ax, [bp+6] ; Load parameter buffer
    push ax ; Save left operand
    ; Postfix increment of variable i
    mov ax, [bp-2] ; Load variable value
    mov bx, ax ; Save original value to BX
    inc bx ; Increment value
    mov [bp-2], bx ; Store incremented value back
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
if_end38:
    ; Assignment statement
    mov ax, 0 ; Load literal
    push ax ; Save right-hand side value
    mov ax, [bp+6] ; Load parameter buffer
    push ax ; Save left operand
    mov ax, [bp-2] ; Load local variable i
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
    ; For loop
    ; For loop initialization
    ; Local variable declaration: j
    mov ax, 0 ; Load literal
    push ax ; Initialize local variable
    jmp for_cond40
for_start39:
    ; For loop body
    ; Local variable declaration: swap
    mov ax, [bp+6] ; Load parameter buffer
    push ax ; Save left operand
    mov ax, [bp-12] ; Load local variable j
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    ; Dereferencing pointer
    mov bx, ax ; Move address to BX
    cmp bx, 0 ; Check for null pointer
    je null_ptr_deref_43
    xor ah, ah ; Clear high byte for char
    mov al, [bx] ; Load byte (char) from memory
    jmp ptr_deref_end_43
null_ptr_deref_43:
    ; Null pointer dereference detected
    mov ax, 0 ; Return 0 for null deref
ptr_deref_end_43:
    push ax ; Initialize local variable
    ; Assignment statement
    mov ax, [bp+6] ; Load parameter buffer
    push ax ; Save left operand
    mov ax, [bp-2] ; Load local variable i
    push ax ; Save left operand
    mov ax, [bp-12] ; Load local variable j
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    sub ax, bx ; Subtraction
    push ax ; Save left operand
    mov ax, 1 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    sub ax, bx ; Subtraction
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    ; Dereferencing pointer
    mov bx, ax ; Move address to BX
    cmp bx, 0 ; Check for null pointer
    je null_ptr_deref_44
    xor ah, ah ; Clear high byte for char
    mov al, [bx] ; Load byte (char) from memory
    jmp ptr_deref_end_44
null_ptr_deref_44:
    ; Null pointer dereference detected
    mov ax, 0 ; Return 0 for null deref
ptr_deref_end_44:
    push ax ; Save right-hand side value
    mov ax, [bp+6] ; Load parameter buffer
    push ax ; Save left operand
    mov ax, [bp-12] ; Load local variable j
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
    ; Assignment statement
    mov ax, [bp-14] ; Load local variable swap
    push ax ; Save right-hand side value
    mov ax, [bp+6] ; Load parameter buffer
    push ax ; Save left operand
    mov ax, [bp-2] ; Load local variable i
    push ax ; Save left operand
    mov ax, [bp-12] ; Load local variable j
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    sub ax, bx ; Subtraction
    push ax ; Save left operand
    mov ax, 1 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    sub ax, bx ; Subtraction
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    add ax, bx ; Addition
    mov bx, ax ; Move pointer address to BX
    pop ax ; Restore right-hand side value
    mov [bx], al ; Store byte value through pointer
for_update41:
    ; For loop update
    ; Postfix increment of variable j
    mov ax, [bp-12] ; Load variable value
    mov bx, ax ; Save original value to BX
    inc bx ; Increment value
    mov [bp-12], bx ; Store incremented value back
for_cond40:
    ; For loop condition
    mov ax, [bp-12] ; Load local variable j
    push ax ; Save left operand
    mov ax, [bp-2] ; Load local variable i
    push ax ; Save left operand
    mov ax, 2 ; Load literal
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    cwd ; Sign extend AX into DX:AX
    idiv bx ; Division (signed)
    mov bx, ax ; Right operand to bx
    pop ax ; Restore left operand
    cmp ax, bx ; Less than comparison
    mov ax, 0  ; Assume false
    jl lt_true_45
    jmp lt_end_45
lt_true_45:
    mov ax, 1  ; Set true
lt_end_45:
    test ax, ax
    jnz for_start39
for_end42:

_stoa_dec_exit:
    ; Standard function epilogue
    mov sp, bp
    pop bp
    ret


; Data section for strings and arrays
; String literals section
test_casting_string_0: db 78, 67, 67, 32, 66, 111, 111, 116, 108, 111, 97, 100, 101, 114, 13, 10, 0  ; null terminator
test_casting_string_1: db 76, 111, 97, 100, 105, 110, 103, 32, 107, 101, 114, 110, 101, 108, 46, 46, 46, 13, 10, 0  ; null terminator
test_casting_string_2: db 83, 105, 103, 110, 101, 100, 32, 118, 97, 108, 117, 101, 58, 32, 0  ; null terminator
test_casting_string_3: db 13, 10, 0  ; null terminator
test_casting_string_4: db 85, 110, 115, 105, 103, 110, 101, 100, 32, 99, 97, 115, 116, 58, 32, 0  ; null terminator
test_casting_string_5: db 13, 10, 0  ; null terminator
test_casting_string_6: db 76, 97, 114, 103, 101, 32, 110, 101, 103, 97, 116, 105, 118, 101, 58, 32, 0  ; null terminator
test_casting_string_7: db 13, 10, 0  ; null terminator
test_casting_string_8: db 76, 97, 114, 103, 101, 32, 117, 110, 115, 105, 103, 110, 101, 100, 58, 32, 0  ; null terminator
test_casting_string_9: db 13, 10, 0  ; null terminator
test_casting_string_10: db 65, 115, 115, 101, 114, 116, 105, 111, 110, 32, 102, 97, 105, 108, 101, 100, 33, 13, 10, 0  ; null terminator

; Array declarations section
_test_casting_global_hex_buffer_0: times 16 db 0 ; Array of 16 bytes
_test_casting_global_dec_buffer_1: times 16 db 0 ; Array of 16 bytes
